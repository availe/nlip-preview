package io.availe.generators

import com.squareup.kotlinpoet.*
import io.availe.builders.buildValueClass
import io.availe.builders.dataClassBuilder
import io.availe.builders.packageName
import io.availe.models.Model
import io.availe.models.Property
import io.availe.models.Variant
import io.availe.utils.fieldsForBase
import io.availe.utils.fieldsForCreate
import io.availe.utils.fieldsForPatch
import java.io.File
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter

val filePath: File = File("build/generated-src/kotlin-poet")

private fun generateVersionedModelFile(baseName: String, versions: List<Model>, out: File) {
    val sortedVersions = versions.sortedByDescending { it.schemaVersion }
    val generatedClassName = baseName + "Schema"
    val fileBuilder = FileSpec.builder(packageName, generatedClassName)

    val now = ZonedDateTime.now()
    val formatter = DateTimeFormatter.ofPattern("EEEE, MMMM d, yyyy 'at' h:mm:ss a z")
    val fileComment = """
    Generated by Availe Codegen. Do not edit.
    
    Generated at: ${now.format(formatter)}
    """.trimIndent()
    fileBuilder.addFileComment(fileComment)

    val propertySignatures = mutableMapOf<String, String>()
    val conflictingProperties = mutableSetOf<String>()

    versions.forEach { version ->
        version.properties.filterIsInstance<Property.Property>().forEach { prop ->
            if (conflictingProperties.contains(prop.name)) return@forEach
            val signature = prop.typeInfo.qualifiedName
            if (propertySignatures.containsKey(prop.name)) {
                if (propertySignatures[prop.name] != signature) {
                    conflictingProperties.add(prop.name)
                    propertySignatures.remove(prop.name)
                }
            } else {
                propertySignatures[prop.name] = signature
            }
        }
    }

    val valueClassNames = versions.flatMap { version ->
        version.properties.filterIsInstance<Property.Property>().map { prop ->
            val name = if (conflictingProperties.contains(prop.name)) {
                "$baseName${version.name}${prop.name.replaceFirstChar { it.uppercaseChar() }}"
            } else {
                "$baseName${prop.name.replaceFirstChar { it.uppercaseChar() }}"
            }
            (version.name to prop.name) to name
        }
    }.toMap()

    val topLevelClass = TypeSpec.classBuilder(generatedClassName)
        .addModifiers(KModifier.SEALED)
        .addAnnotation(ClassName("kotlinx.serialization", "Serializable"))
        .addKdoc(
            """
            =================================================================
            SCHEMA DEFINITION: %L
            =================================================================
            
            A sealed class hierarchy representing all known versions of the %L data model.
            
            This class acts as a namespace for all versioned DTOs. When consuming this data,
            it is recommended to handle the latest version first (`%L`) and provide
            graceful fallback mechanisms for older versions.
            """.trimIndent(),
            generatedClassName, baseName, sortedVersions.first().name
        )

    sortedVersions.forEach { version ->
        val versionClass = TypeSpec.classBuilder(version.name)
            .addModifiers(KModifier.SEALED)
            .superclass(ClassName(packageName, generatedClassName))
            .addAnnotation(ClassName("kotlinx.serialization", "Serializable"))
            .addKdoc(
                """
                --------------------------
                |   Version %L (%L)   |
                --------------------------
                """.trimIndent(), version.schemaVersion!!, version.name
            )

        val dtoSpecs = listOf(
            fieldsForBase(version) to Variant.BASE,
            fieldsForCreate(version) to Variant.CREATE,
            fieldsForPatch(version) to Variant.PATCH
        ).mapNotNull { (fields, variant) ->
            if (fields.isNotEmpty()) dataClassBuilder(version, fields, variant, valueClassNames) else null
        }
        dtoSpecs.forEach { versionClass.addType(it) }

        topLevelClass.addType(versionClass.build())
    }
    fileBuilder.addType(topLevelClass.build())

    var allValueClasses = versions.flatMap { version ->
        version.properties.filterIsInstance<Property.Property>().map { prop ->
            val className = valueClassNames[version.name to prop.name]!!
            val isSerializable = version.annotations?.any { it.qualifiedName == "kotlinx.serialization.Serializable" } == true
            className to buildValueClass(className, prop, isSerializable)
        }
    }.distinctBy { it.first }.sortedBy { it.first }.map { it.second }

    if (allValueClasses.isNotEmpty()) {
        val headerKdoc = CodeBlock.of(
            """
            =================================================================
            VALUE CLASSES
            =================================================================
            
            Type-safe wrappers for the properties used in the %L.
            These classes prevent primitive obsession and ensure that, for example,
            an ID for one model cannot be accidentally used as an ID for another.
            """.trimIndent(), generatedClassName
        )
        val firstValueClassWithHeader = allValueClasses.first().toBuilder()
            .addKdoc(headerKdoc)
            .build()
        allValueClasses = listOf(firstValueClassWithHeader) + allValueClasses.drop(1)
    }

    allValueClasses.forEach { fileBuilder.addType(it) }

    fileBuilder.build().writeTo(out)
}

fun generateDataClasses(models: List<Model>) {
    val out: File = filePath
    val groupedModels = models.groupBy { it.isVersionOf ?: it.name }

    groupedModels.forEach { (baseName, modelVersions) ->
        val isVersioned = modelVersions.first().isVersionOf != null
        if (isVersioned) {
            generateVersionedModelFile(baseName, modelVersions, out)
        } else {
            generateStandaloneModel(modelVersions.first(), out)
        }
    }
}

private fun generateStandaloneModel(model: Model, out: File) {
    val fileBuilder = FileSpec.builder(packageName, model.name + "Schema")

    val now = ZonedDateTime.now()
    val formatter = DateTimeFormatter.ofPattern("EEEE, MMMM d, yyyy 'at' h:mm:ss a z")
    val fileComment = """
    Generated by Availe Codegen. Do not edit.
    
    Generated at: ${now.format(formatter)}
    """.trimIndent()
    fileBuilder.addFileComment(fileComment)

    model.optInMarkers?.forEach { marker ->
        val markerClass = ClassName(marker.substringBeforeLast('.'), marker.substringAfterLast('.'))
        fileBuilder.addAnnotation(
            AnnotationSpec.builder(ClassName("kotlin", "OptIn"))
                .addMember("%T::class", markerClass)
                .build()
        )
    }

    val valueClassNames = model.properties
        .filterIsInstance<Property.Property>()
        .associate { (model.name to it.name) to "${model.name}${it.name.replaceFirstChar { c -> c.uppercaseChar() }}" }


    val dtoSpecs = listOf(
        fieldsForBase(model) to Variant.BASE,
        fieldsForCreate(model) to Variant.CREATE,
        fieldsForPatch(model) to Variant.PATCH
    ).mapNotNull { (fields, variant) ->
        if (fields.isNotEmpty()) dataClassBuilder(model, fields, variant, valueClassNames) else null
    }

    dtoSpecs.forEach { fileBuilder.addType(it) }

    var valueClassSpecs = model.properties
        .filterIsInstance<Property.Property>()
        .map { prop ->
            val className = valueClassNames[model.name to prop.name]!!
            val isSerializable = model.annotations?.any { it.qualifiedName == "kotlinx.serialization.Serializable" } == true
            buildValueClass(className, prop, isSerializable)
        }
        .sortedBy { it.name }

    if (valueClassSpecs.isNotEmpty()) {
        val headerKdoc = CodeBlock.of(
            """
            =================================================================
            VALUE CLASSES
            =================================================================
            """.trimIndent()
        )
        val firstValueClassWithHeader = valueClassSpecs.first().toBuilder()
            .addKdoc(headerKdoc)
            .build()
        valueClassSpecs = listOf(firstValueClassWithHeader) + valueClassSpecs.drop(1)
    }

    valueClassSpecs.forEach { fileBuilder.addType(it) }

    fileBuilder.build().writeTo(out)
}