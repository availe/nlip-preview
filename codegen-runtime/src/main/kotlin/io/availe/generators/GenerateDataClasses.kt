package io.availe.generators

import com.squareup.kotlinpoet.*
import io.availe.builders.buildValueClass
import io.availe.builders.dataClassBuilder
import io.availe.builders.packageName
import io.availe.models.Model
import io.availe.models.Property
import io.availe.models.Variant
import io.availe.utils.fieldsForBase
import io.availe.utils.fieldsForCreate
import io.availe.utils.fieldsForPatch
import java.io.File

val filePath: File = File("build/generated-src/kotlin-poet")

private fun generateVersionedModelFile(baseName: String, versions: List<Model>, out: File) {
    val sortedVersions = versions.sortedByDescending { it.schemaVersion }
    val generatedClassName = baseName + "Schema"
    val fileBuilder = FileSpec.builder(packageName, generatedClassName)
    fileBuilder
        .addFileComment("Generated by KReplica. Do not edit.")
        .addOptInMarkersForModels(versions)
    val propertySignatures = mutableMapOf<String, String>()
    val conflictingProperties = mutableSetOf<String>()

    versions.forEach { version ->
        version.properties.filterIsInstance<Property.Property>().forEach { prop ->
            if (conflictingProperties.contains(prop.name)) return@forEach
            val signature = prop.typeInfo.qualifiedName
            if (propertySignatures.containsKey(prop.name)) {
                if (propertySignatures[prop.name] != signature) {
                    conflictingProperties.add(prop.name)
                    propertySignatures.remove(prop.name)
                }
            } else {
                propertySignatures[prop.name] = signature
            }
        }
    }

    val valueClassNames = versions.flatMap { version ->
        version.properties.filterIsInstance<Property.Property>().map { prop ->
            val name = if (conflictingProperties.contains(prop.name)) {
                "$baseName${version.name}${prop.name.replaceFirstChar { it.uppercaseChar() }}"
            } else {
                "$baseName${prop.name.replaceFirstChar { it.uppercaseChar() }}"
            }
            (version.name to prop.name) to name
        }
    }.toMap()

    val topLevelClass = TypeSpec.classBuilder(generatedClassName)
        .addModifiers(KModifier.SEALED)
        .addAnnotation(ClassName("kotlinx.serialization", "Serializable"))
        .addKdoc("A sealed class hierarchy representing all known versions of the %L data model.", baseName)

    sortedVersions.forEach { version ->
        val versionClass = TypeSpec.classBuilder(version.name)
            .addModifiers(KModifier.SEALED)
            .superclass(ClassName(packageName, generatedClassName))
            .addAnnotation(ClassName("kotlinx.serialization", "Serializable"))
            .addKdoc("Version %L", version.schemaVersion!!)

        val dtoSpecs = listOf(
            fieldsForBase(version) to Variant.BASE,
            fieldsForCreate(version) to Variant.CREATE,
            fieldsForPatch(version) to Variant.PATCH
        ).mapNotNull { (fields, variant) ->
            if (fields.isNotEmpty()) dataClassBuilder(version, fields, variant, valueClassNames) else null
        }
        dtoSpecs.forEach { versionClass.addType(it) }

        topLevelClass.addType(versionClass.build())
    }
    fileBuilder.addType(topLevelClass.build())

    val allValueClassData = versions.flatMap { version ->
        version.properties.filterIsInstance<Property.Property>().map { prop ->
            Triple(prop, version, valueClassNames[version.name to prop.name]!!)
        }
    }.distinctBy { it.third }

    val (conflictedData, sharedData) = allValueClassData.partition { (prop, _, _) ->
        conflictingProperties.contains(prop.name)
    }

    if (sharedData.isNotEmpty()) {
        val sharedHeader =
            "SHARED VALUE CLASSES\n\nType-safe wrappers for properties that are consistent across versions."
        var sharedClasses = sharedData.map { (prop, version, className) ->
            val isSerializable =
                version.annotations?.any { it.qualifiedName == "kotlinx.serialization.Serializable" } == true
            buildValueClass(className, prop, isSerializable)
        }.sortedBy { it.name }
        val firstWithHeader = sharedClasses.first().toBuilder().addKdoc(sharedHeader).build()
        sharedClasses = listOf(firstWithHeader) + sharedClasses.drop(1)
        sharedClasses.forEach { fileBuilder.addType(it) }
    }

    if (conflictedData.isNotEmpty()) {
        val conflictedHeader = "CONFLICTED (VERSION-SPECIFIC) VALUE CLASSES\n\n" +
                "Type-safe wrappers for properties that have different underlying types in different schema versions."
        var conflictedClasses = conflictedData.map { (prop, version, className) ->
            val isSerializable =
                version.annotations?.any { it.qualifiedName == "kotlinx.serialization.Serializable" } == true
            buildValueClass(className, prop, isSerializable)
        }.sortedBy { it.name }
        val firstWithHeader = conflictedClasses.first().toBuilder().addKdoc(conflictedHeader).build()
        conflictedClasses = listOf(firstWithHeader) + conflictedClasses.drop(1)
        conflictedClasses.forEach { fileBuilder.addType(it) }
    }

    fileBuilder.build().writeTo(out)
}

fun generateDataClasses(models: List<Model>) {
    val out: File = filePath
    val groupedModels = models.groupBy { it.isVersionOf ?: it.name }

    groupedModels.forEach { (baseName, modelVersions) ->
        val isVersioned = modelVersions.first().isVersionOf != null
        if (isVersioned) {
            generateVersionedModelFile(baseName, modelVersions, out)
        } else {
            generateStandaloneModel(modelVersions.first(), out)
        }
    }
}

private fun generateStandaloneModel(model: Model, out: File) {
    val fileBuilder = FileSpec.builder(packageName, model.name + "Schema")
    fileBuilder.addFileComment("Generated by KReplica. Do not edit.")

    model.optInMarkers?.forEach { marker ->
        val markerClass = ClassName(marker.substringBeforeLast('.'), marker.substringAfterLast('.'))
        fileBuilder.addAnnotation(
            AnnotationSpec.builder(ClassName("kotlin", "OptIn"))
                .addMember("%T::class", markerClass)
                .build()
        )
    }

    val valueClassNames = model.properties
        .filterIsInstance<Property.Property>()
        .associate { (model.name to it.name) to "${model.name}${it.name.replaceFirstChar { c -> c.uppercaseChar() }}" }

    val dtoSpecs = listOf(
        fieldsForBase(model) to Variant.BASE,
        fieldsForCreate(model) to Variant.CREATE,
        fieldsForPatch(model) to Variant.PATCH
    ).mapNotNull { (fields, variant) ->
        if (fields.isNotEmpty()) dataClassBuilder(model, fields, variant, valueClassNames) else null
    }

    dtoSpecs.forEach { fileBuilder.addType(it) }

    var valueClassSpecs = model.properties
        .filterIsInstance<Property.Property>()
        .map { prop ->
            val className = valueClassNames[model.name to prop.name]!!
            val isSerializable =
                model.annotations?.any { it.qualifiedName == "kotlinx.serialization.Serializable" } == true
            buildValueClass(className, prop, isSerializable)
        }
        .sortedBy { it.name }

    if (valueClassSpecs.isNotEmpty()) {
        val headerKdoc = "VALUE CLASSES"
        val firstValueClassWithHeader = valueClassSpecs.first().toBuilder()
            .addKdoc(headerKdoc)
            .build()
        valueClassSpecs = listOf(firstValueClassWithHeader) + valueClassSpecs.drop(1)
    }

    valueClassSpecs.forEach { fileBuilder.addType(it) }

    fileBuilder.build().writeTo(out)
}

fun FileSpec.Builder.addOptInMarkers(markers: List<String>?) {
    markers?.forEach { fq ->
        val pkg = fq.substringBeforeLast('.')
        val name = fq.substringAfterLast('.')
        val marker = ClassName(pkg, name)
        addAnnotation(
            AnnotationSpec.builder(ClassName("kotlin", "OptIn"))
                .addMember("%T::class", marker)
                .build()
        )
    }
}

fun FileSpec.Builder.addOptInMarkersForModels(models: List<Model>): FileSpec.Builder = apply {
    models.flatMap { it.optInMarkers ?: emptyList() }
        .distinct()
        .forEach { fq ->
            val pkg = fq.substringBeforeLast('.')
            val name = fq.substringAfterLast('.')
            val markerClass = ClassName(pkg, name)
            addAnnotation(
                AnnotationSpec.builder(ClassName("kotlin", "OptIn"))
                    .addMember("%T::class", markerClass)
                    .build()
            )
        }
}
