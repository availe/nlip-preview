package io.availe.models

import io.availe.openapi.model.NLIPSubMessageContent
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonObject
import org.jooq.JSONB

/**
 * Utility functions for handling NLIPSubMessageContent
 */

// Map to store JsonElement associated with NLIPSubMessageContent instances
private val contentMap = mutableMapOf<NLIPSubMessageContent, JsonElement>()

/**
 * Create a NLIPSubMessageContent from a JsonElement
 * This is a workaround for the empty NLIPSubMessageContent class generated by OpenAPI
 */
fun createNLIPContent(jsonElement: JsonElement): NLIPSubMessageContent {
    // Since NLIPSubMessageContent is an empty class, we'll just create an instance
    // and store the JsonElement separately for use in the mapper
    val content = NLIPSubMessageContent()
    contentMap[content] = jsonElement
    return content
}

/**
 * Get JsonElement from NLIPSubMessageContent
 */
fun NLIPSubMessageContent.getJsonElement(): JsonElement {
    return contentMap[this] ?: JsonObject(emptyMap())
}

/**
 * Convert NLIPSubMessageContent to JSONB using the stored JsonElement
 */
fun NLIPSubMessageContent.toContentJsonb(): JSONB {
    val jsonElement = getJsonElement()
    return jsonElement.toJsonb()
}

/**
 * Convert JsonElement to JSONB using the existing toJsonb function
 */
fun JsonElement.toJsonb(): JSONB {
    return JSONB.valueOf(NLIP_JSON.encodeToString(JsonElement.serializer(), this))
}

/**
 * Create NLIPSubMessageContent from JSONB
 */
fun JSONB.toNLIPContent(): NLIPSubMessageContent {
    val jsonElement = this.toJsonElement()
    return createNLIPContent(jsonElement)
}